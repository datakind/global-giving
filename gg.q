\l stat.q

////////////////////////////////////////////////////////////////////////
// Global Giving project-specific functions
////////////////////////////////////////////////////////////////////////

// loadall: obsolete
/ uses lt to load all *2.csv files found in the current directory
/ not needed anymore since we have format strings; use load2 instead.
loadall:{
  f:{x where x like"*2.csv"}key`:.; / data files in pwd
  t:`$.[;(::;0)]"."vs/:string f;    / derive table names
  {.[x;();:;lt x]}each t}           / create global tables

/ format strings for the 7 original raw files (with quoted newlines removed)
/ Started with output of 'fmt lt tab' and then tweaked by hand.
organfmt:"ISPP*****SS*S***IIIIPIPSS";
projefmt:"ISSIPP******S*****SSS*S*SSFPF*********PPPSIFIFIIIIPI";
rcptfmt:"IFFPIISISIISIIIII**SIFF**II";
rcptifmt:"IIFIIISIII**I*****IIIISPIF";
recurfmt:"IISFPPPPIIFIISSFFSS";
uausefmt:"IIPPS*S*SSS*SIIPIPII";
valuefmt:"IIIP*";

// bn: basename
/ chop off dirs, extension, and version number from the back
/ of a data file path
/ x file handle eg `:data/organization2.csv
/ return C eg "organization"
bn:{
  f:first` vs last` vs x; / base file name (still has version #)
  / drop consecutive digits from the back of f
  reverse{_[;x]sum(and\)10>.Q.n?x}reverse string f}

// lf: load fast helper
/ uses pre-calculated format strings stored in globals
/ whose names are based on the table name
/ x file handle e.g., `:data/organization.csv
/ creates the table in the global namespace
lf:{
  t:`$bn x;                          / table name
  f:value(5 sublist string t),"fmt"; / get format string from global
  t set trimstr fixnullstr fixnullsym(f;(),",")0:x}

// load2: load the 7 original tables using their format strings
/ assumes the files have been processed by rnq and have 2 in the name
/ x optional directory containing the csv files
load2:{
/ t:`organization`project`rcpt`rcptitem`recurring`uauser`value_outcome;
  t:`organization2`project2`rcpt2`rcptitem2`recurring2`uauser2`value_outcome2;
  lf each` sv/:hsym[$[null x;`.;x]],/:` sv/:t,\:`csv}

// loadfast: load the tables in kdb format
/ they must have been previously saved in kdb format using savefast.
/ x optional dir to find table files in kdb format
loadfast:{
 load each` sv/:hsym[x],/:{x where not x like"*.*"}key hsym x}

// savefast: save all the tables current in memory in kdb format
/ x optional dir to save the files in
savefast:{
  x{(` sv hsym[x],y)set value y}/:tables`}

// val: add val column (and line_item_id and volume_bucket_id) to rcptitem
/ focus on only funded and retired projects
val:{
  update val:amount*quantity from
    select from rcptitem lj
                  `rcptid xkey(select rcptid, line_item_id, volume_bucket_id
                                 from rcpt)
      where projid in
        exec distinct projid from project
          where status in`funded`retired}

// helper for summary Jon's aggregation
agg:{
  update direct_frac        :direct_frac % num_donations,
         disaster_frac      :disaster_frac % num_donations,
         open_challenge_frac:open_challenge_frac % num_donations
    from
      select total_raised       :sum val,
             mean_donation      :avg val,
             median_donation    :med val,
             max_donation       :max val,
             min_donation       :{?[0w=x;0f;x]}min{x where x>0}val,
             num_donations      :`float$sum signum val, / why, when reading Jon's file, does lt think this col is float?
             direct_frac        :sum signum val where line_item_id=135,
             disaster_frac      :sum signum val where line_item_id=103,
             open_challenge_frac:sum signum val where volume_bucket_id=6
        by projid
        from val[]}

// summary: attempt to imitate Jon's summary table
summary:{
  t:(select projid,
            projtitle,
            projamt,
            status,
            createdt,
            approveddt,
            deactivateDate
       from project where status in`funded`retired)
    lj agg[];
  / replace nulls (generated by join) with 0
  @[t;
    `total_raised`mean_donation`median_donation`max_donation`min_donation,
      `num_donations`direct_frac`disaster_frac`open_challenge_frac;
    0f^]}

donations:{
  ()xkey select sum amount*quantity by projid, creatdt from rcptitem}

/ count how many projects received funds in particular currencies
/ select n:count i by currency_code from currcounts[]
currcounts:{
  1_()xkey / drop null projid
    select `#asc distinct currency_code
      by projid from
        (select rcptid, currency_code from rcpt)
          lj
        `rcptid xkey select rcptid, projid, amount, quantity from rcptitem}

// addkeys: define foreign key relationships so we can use dot notation
/ for simple joins, eg
/ ()xkey select val:sum amount*quantity by projid,`month$creatdt
/    from rcptitem where projid.status in`funded`retired
addkeys:{
  / delete the dangling projids from rcptitem
  delete from `rcptitem where not projid in exec distinct projid from project;
  `projid xkey`project;
  update projid:`project$projid from `rcptitem}

/ q)loadfast`:data / dir containing the rnq'd data files
/ q)tables`.
/ `organization`project`rcpt`rcptitem`recurring`uauser`value_outcome
/ q)d:donations[]
/ q)s:summary[]
