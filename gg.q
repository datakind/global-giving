// (c) DataKind
// written by Nate McNamara

\l stat.q

////////////////////////////////////////////////////////////////////////
// Global Giving project-specific functions
////////////////////////////////////////////////////////////////////////

// loadall: obsolete
/ uses lt to load all *2.csv files found in the current directory
/ not needed anymore since we have format strings; use load2 instead.
loadall:{
  f:{x where x like"*2.csv"}key`:.; / data files in pwd
  t:`$.[;(::;0)]"."vs/:string f;    / derive table names
  {.[x;();:;lt x]}each t}           / create global tables

/ format strings for the 7 original raw files (with quoted newlines removed)
/ Started with output of 'fmt lt tab' and then tweaked by hand.
/ MAYBE: F -> E and P -> D to save memory
googfmt:"ISIPPSDDS*IIIEEIIIIIIEIIIIII";
line_fmt:"ISBIEEESI";
organfmt:"ISPP*****SS*S***IIIIPIPSS";
projefmt:"ISSIPP******S*****SSS*S*SSEPE*********PPPSIEIEIIIIPI";
rcptfmt:"IEEPIISISIISIIIII**SIEE**II";
rcptifmt:"IIEIIISIII**I*****IIIISPIE";
recurfmt:"IISEPPPPIIEIISSEESS";
recurfmt:"IISEIISSBPPS";
uausefmt:"IIPPS*S*SSS*SIIPIPII";
usdbpfmt:"IPEEE";
usmbpfmt:"IMEEEIIE";
valuefmt:"IIIP*";

/ projectNumbericalSummary.csv format
pnsfmt:"I*SSESPPPEEEEEEEEE"; / upper{@[x;where"C"=x;:;"*"]}exec t from meta s;
/ obsolete
/ NB: don't name a column type! q doesn't like it
/ pns:@[;`num_donations;`int$]@[;`projtitle;trim]`projid`projtitle`ptype xcol lt`projectNumericalSummary;

// bn: basename
/ chop off dirs, extension, and version number from the back
/ of a data file path
/ x file handle eg `:data/organization2.csv
/ return C eg "organization"
bn:{
  f:first` vs last` vs x; / base file name (still has version #)
  / drop consecutive digits from the back of f
  reverse{_[;x]sum(and\)10>.Q.n?x}reverse string f}

// lf: load fast helper
/ uses pre-calculated format strings stored in globals
/ whose names are based on the table name
/ x file handle e.g., `:data/organization.csv
/ creates the table in the global namespace
lf:{
  t:`$bn x;                          / table name
  f:value(5 sublist string t),"fmt"; / get format string from global
  t set trimstr fixnullstr fixnullsym(f;(),",")0:x}

// load2: load the 7 original tables using their format strings
/ assumes the files have been processed by rnq and have 2 in the name
/ x optional directory containing the csv files
load2:{
/ t:`organization`project`rcpt`rcptitem`recurring`uauser`value_outcome;
  t:`goog`organization2`project2`rcpt2`rcptitem2`recurring2`uauser2`value_outcome2;
  lf each` sv/:hsym[$[null x;`.;x]],/:` sv/:t,\:`csv}

// loadfast: load the tables in kdb format
/ they must have been previously saved in kdb format using savefast.
/ x optional dir to find table files in kdb format
loadfast:{
 load each` sv/:hsym[x],/:{x where not x like"*.*"}key hsym x}

// savefast: save all the tables current in memory in kdb format
/ x optional dir to save the files in
savefast:{
  x{(` sv hsym[x],y)set value y}/:tables`}

// val: add val column (and line_item_id and volume_bucket_id) to rcptitem
/ focus on only funded and retired projects
val:{
  update val:amount*quantity from
    select from rcptitem lj
                  `rcptid xkey(select rcptid, line_item_id, volume_bucket_id
                                 from rcpt)
      where projid in
        exec distinct projid from project
          where status in`funded`retired}

// helper for summary Jon's aggregation
agg:{
  update direct_frac        :direct_frac % num_donations,
         disaster_frac      :disaster_frac % num_donations,
         open_challenge_frac:open_challenge_frac % num_donations
    from
      select total_raised       :sum val,
             mean_donation      :avg val,
             median_donation    :med val,
             max_donation       :max val,
             min_donation       :{?[0w=x;0f;x]}min{x where x>0}val,
             num_donations      :sum signum val,
             direct_frac        :sum signum val where line_item_id=135,
             disaster_frac      :sum signum val where line_item_id=103,
             open_challenge_frac:sum signum val where volume_bucket_id=6
        by projid
        from val[]}

// summary: attempt to imitate Jon's summary table
summary:{
  t:(select projid,
            projtitle,
            ptype,
            projthemeid,
            projamt,
            status,
            createdt,
            approveddt,
            deactivateDate
       from project where status in`funded`retired)
    lj agg[];
  / replace nulls (generated by join) with 0
  @[@[t;`num_donations;0i^];
    `total_raised`mean_donation`median_donation`max_donation`min_donation,
      `direct_frac`disaster_frac`open_challenge_frac;
    0f^]}

// ustsdbp: attempt to replicate Jon's us_timeseries_donations_byProject.csv
/ donations and total by projid,date:creatdt
/ note that date is really a timestamp
ustsdbp:{
  ()xkey
    select donated  :sum amount*quantity,
           donations:sum 0<amount,
           refunds  :sum 0>amount
      by projid, date:creatdt
      from rcptitem
      where currency_code=`USD}

// ustsdbp2: attempt to replicate Jon's us_timeseries_donations_byProject.csv
/ as of his new code since 11/7/14
/ donated,donations,refunds,pageviews,visitors by projid,date
ustsdbp2:{
  update conversion_rate:donations%visitors from
      (()xkey
         select donated  :sum amount*quantity,
                donations:sum 0<amount,
                refunds  :sum 0>amount
           by projid, date:`date$creatdt
           from rcptitem
           where currency_code=`USD, recurringitemid<=0)
    lj
      select sum pageviews, sum visitors
        by projid:reference_id, date:start_date
        from goog}
/ ts:ustsdbp2[]
/ x:update conversion_rate:?[0>=visitors;0f;(donations-refunds)%visitors] from ()xkey select sum donated,sum donations,sum refunds,sum pageviews,sum visitors by projid,month:`month$date from ts
/ y:flip@[;exec c from meta x where t in"ief";0^]cols[x]!"imeiiiif"$value flip("IMEEEEEF";(),",")0:`$":jon/repo/opportunity-analysis/conversionRateStudy/us_timeseries_monthly_donations_byProject.csv"
/ The latest code excludes rows with no visitors
/ sub:select from ts where 0<visitors
/ m:()xkey select sum donations,sum refunds,sum pageviews,sum visitors by projid,month:`month$date from sub
/ mcr:update conversion_rate:(donations-refunds)%visitors from m

/ count how many projects received funds in particular currencies
/ select n:count i by currency_code from currcounts[]
currcounts:{
  1_()xkey / drop null projid
    select `#asc distinct currency_code
      by projid from
        (select rcptid, currency_code from rcpt)
          lj
        `rcptid xkey select rcptid, projid, amount, quantity from rcptitem}

// addkeys: define foreign key relationships so we can use dot notation
/ for simple joins, eg
/ ()xkey select val:sum amount*quantity by projid,`month$creatdt
/    from rcptitem where projid.status in`funded`retired
addkeys:{
  / key target tables
  `id`id`projid`rcptid`recurringid`uauserid xkey'
    `line_item`organization`project`rcpt`recurring`uauser;

  / delete the dangling fkeys and then make the links
  delete from `goog where not reference_id in
    exec distinct projid from project;
  update projid:`project$reference_id from `goog;

  update organization_id:`organization$organization_id from `project;
  update line_item_id:`line_item$line_item_id,
         uauserid:`uauser$uauserid
    from `rcpt;

  delete from `rcptitem where
    (not projid in exec distinct projid from project)|
    not rcptid in exec distinct rcptid from rcpt;
  update organization_id:`organization$organization_id,
         projid:`project$projid,
         rcptid:`rcpt$rcptid
    from `rcptitem;

  delete from `roll_rcptitem where
    (not projid in exec distinct projid from project)|
    not rcptid in exec distinct rcptid from rcpt;
  update projid:`project$projid from `roll_rcptitem;

  update uauserid:`uauser$uauserid from `recurring;

  delete from `recurringitem where
    (not projid in exec projid from project)|
    not recurringid in exec recurringid from recurring;
  update organization_id:`organization$organization_id,
         projid:`project$projid,
         recurringid:`recurring$recurringid
    from `recurringitem;

  update projid:`project$projid from `value_outcome;
  }

// roll: roll-up recurring items in rcptitem
roll:{
  select
    from (update sum quantity by recurringitemid
            from rcptitem where recurringitemid>0)
    where (recurringitemid<=0) or i=(first;i)fby recurringitemid}

// dbd: donations by projid,date
/ x s optional currency eg `USD
dbd:{
  ()xkey
    $[null x;
      select total_donated  :sum amount*quantity,
             total_donations:sum 0<amount,
             total_refunds  :sum 0>amount
        by projid, date:`date$creatdt
        from roll_rcptitem;
      select total_donated  :sum amount*quantity,
             total_donations:sum 0<amount,
             total_refunds  :sum 0>amount
        by projid, date:`date$creatdt
        from roll_rcptitem
        where currency_code=x]}

dbm:{
  ()xkey
    $[null x;
      select donations:sum signum amount,sum amount*quantity
        by projid, month:`month$creatdt
        from rcptitem;
      select donations:sum signum amount,sum amount*quantity
        by projid, month:`month$creatdt
        from rcptitem
        where currency_code=x]}

// dbp: donations by projid
/ x s optional currency eg `USD
dbp:{
  ()xkey
  $[null x;
    select donations:sum signum amount,sum amount*quantity
      by projid from rcptitem;
    select donations:sum signum amount,sum amount*quantity
      by projid from rcptitem where currency_code=x]}

// crbpd: conversion rates by projid,date
crbpd:{
  t:select
      from (dbd[`USD] lj
            select sum visits
              by projid:reference_id, date:start_date
              from goog)
      where not null visits;
  update cr:donations%visits,dpv:amount%visits from t where 0<visits}

// crbpm: conversion rates by projid,month
crbpm:{
  t:select
      from (dbm[`USD] lj
            select sum visits
              by projid:reference_id, month:`month$start_date
              from goog)
      where not null visits;
  update cr:donations%visits,dpv:amount%visits from t where 0<visits}

// crbp: conversion rates by projid
crbp:{
  t:select
     from (dbp[`USD] lj
           select sum visits by projid:reference_id from goog)
      where not null visits;
  `cr xdesc
    update cr:donations%visits,dpv:amount%visits
      from t where 0<visits}

/ q)loadfast`:data / dir containing the rnq'd data files
/ q)tables`.
/ `organization`project`rcpt`rcptitem`recurring`uauser`value_outcome
/ q)d:dbd[] / donations by date
/ q)s:summary[]
/ who is donating?
/ q)select n:count i,sum val:quantity*amount by uauserid from update rcptid.uauserid from rcptitem
/ q)select sum amount by projid,date from d
/ q)select sum visits by projid,start_date from goog
/ q)crated:crd[] / by projid and date
/ q)crate:cr[]  / ignoring dates

prep:{
  loadfast`data;
  summary::summary[];
  addkeys[];
  / uastatus => real user
  donor::select from uauser
           where uastatus=1,
                 uauserid in exec distinct uauserid from rcpt;
  .Q.gc[];
  }

////////////////////////////////////////////////////////////////////////
// monthly donations and visitors/pageviews
// conversion_rate does not connect visits directly to donations,
// it's a straight donations/visitors
make_usmbp:{
  update conversion_rate:(donations-refunds)%visitors from
    (select donations:sum 0<amount,
            refunds  :sum 0>amount,
            raised   :sum amount*quantity
       by projid, month:`month$creatdt
       from rcptitem)
      lj
    select sum pageviews, sum visitors
      by projid:reference_id,
         month:`month$start_date
      from goog}

// vbpd: visitors (and visits etc) by projid,date
/ We have 2,456,780 rows with visitors, but only 1,595,543 with visits (!?)
/ All rows with 0<visits have 0<visitors,
/   but we have 188,404 rows with 0<visits<visitors
vbpd:{
  select sum visitors, sum visits, sum bounces, sum pageviews
    by projid:reference_id, date:start_date
    from goog where 0<visits}

// dbpd: donations (and refunds and [total] raised) by projid,date
/ x s optional currency
dbpd:{
  $[null x;
    select donations:sum 0<amount,
           refunds  :sum 0>amount,
           raised   :sum amount*quantity
      by projid, date:`date$creatdt
      from roll rcptitem;
    select donations:sum 0<amount,
           refunds  :sum 0>amount,
           raised   :sum amount*quantity
      by projid, date:`date$creatdt
      from roll[rcptitem] where currency_code=x]}

// vdbp: visitors and donations by projid
/ x s optional currency
vdbp:{
  {delete from x where donations<refunds}
    select sum visitors, sum visits, sum bounces, sum pageviews,
            sum donations, sum refunds, sum raised
       by projid
       from vbpd[] lj dbpd x}

// vdbpm: visitors and donations by projid,month
/ x s optional currency
vdbpm:{
  {delete from x where ((sum;donations)fby projid)<(sum;refunds)fby projid}
    select sum visitors, sum visits, sum bounces, sum pageviews,
           sum donations, sum refunds, sum raised
       by projid, month:`month$date
       from vbpd[] lj dbpd x}

// pcr: project conversion rate
/ Only includes donations in USD
pcr:{
  cr:update dpvisitor :(donations-refunds)%visitors,
            dpvisit   :(donations-refunds)%visits,
            mpvisitor :raised%visitors,
            mpvisit   :raised%visits,
            pct_raised:raised%projamt
       from 0!vdbp[`USD] lj
            1!select projid,projamt,projthemeid,projtitle from project;
  (`projid`dpvisitor`dpvisit`mpvisitor`mpvisit`visitors`visits`bounces,
     `pageviews`donations`refunds`raised`projamt`pct_raised)
    xcols `dpvisit xdesc cr}
// update cr:.2*cr,h:(`int$.1*n)#\:"*" from select n:count i by cr:`int$5*10 xlog dpvisit from pcr[] where dpvisit>0,10<donations
  
// pcrbm: project conversion rate by month
/ Only includes donations in USD
pcrbm:{
  crbm:update dpvisitor:(donations-refunds)%visitors,
              dpvisit  :(donations-refunds)%visits,
              mpvisitor:raised%visitors,
              mpvisit  :raised%visits
         from ()xkey vdbpm`USD;
  `projid`month`dpvisitor`dpvisit`mpvisitor`mpvisit xcols crbm}

// ocr: overall conversion-rate
ocr:{
  // projects with goog data
  p:(exec distinct projid from rcptitem)inter exec distinct projid from goog;
  r:update pct_raised:raised%projamt from
      select donations:sum 0<amount,
             refunds  :sum 0>amount,
             projamt  :first projid.projamt,
             raised   :sum amount*quantity
        by projid
        from roll_rcptitem
        where projid in p;
  a:()xkey update conversion_rate:(donations-refunds)%visitors from
      r lj select sum visitors by projid:reference_id from goog;
  `projid`conversion_rate`visitors xcols
    (`conversion_rate xdesc a) lj
      `projid xkey select projid,projthemeid,projtitle from project}

// ocrf overall conversion rate restricted to
/    projid.status=`funded
/    projects whose first check arrived after we start collecting goog data
ocrf:{
  // projects with goog data
  p:exec distinct projid from rcptitem where
      projid.status=`funded,
      (exec first start_date from goog)<=(first;creatdt)fby projid;
  r:update pct_raised:raised%projamt from
      select donations:sum 0<amount,
             refunds  :sum 0>amount,
             projamt  :first projid.projamt,
             raised   :sum amount*quantity
        by projid
        from roll_rcptitem
        where projid in p;
  a:()xkey update conversion_rate:(donations-refunds)%visitors from
      r lj select sum visitors by projid:reference_id from goog;
  `projid`conversion_rate`visitors xcols
    (`conversion_rate xdesc a) lj
      `projid xkey select projid,projthemeid,projtitle from project}

////////////////////////////////////////////////////////////////////////
/ Success histogram
success:{
  `n xdesc
    update h:(`int$100*n)#\:"*" from
      select n:sum[total_raised>=.7*projamt]%count i
        by projthemeid
        from summary[]
        where status=`funded}

////////////////////////////////////////////////////////////////////////
/ Words in project titles, summaries, ...

// wtp: words to project row numbers
/ works like group but one level deeper
/ x list of list of C
/ takes a few seconds
/ TODO: handle punctuation better
/       reduce words to stems
/       count punctuation marks as distinct words?
wtp:{
  if[`i in key`.;
     '"wtp overwrites global var i, but i is already defined"];

  w:({x where x in .Q.a,"-"}'')lower" "vs/:x; / words in each element of x

  i::0; / gross but I haven't found a better way to append row #s
  f:(enlist[""]!enlist(),-1){x@[;;,;-1+i+::1]/y}/w; / words!projrows
  delete i from `.;

  (!).(key f;value f)@\:where not key[f]in / remove uninteresting words
    ("";(),"&";(),"-";(),"a";"an";"and";"are";"as";"at";
     "be";"but";"by";"for";"from";
     "in";"is";"it";"of";"on";"or";
     "that";"the";"their";"this";"to";
     "was";"which";"will";"with")}

// word ratios table
/ x output of wtp
wrt:{
  p:(exec status from project)x;
  t:([]word   :key p;
       funded :sum each`funded=value p;
       retired:sum each`retired=value p;
       total  :count each value p);
  `pct2 xdesc update pct:funded%funded+retired,pct2:funded%total from t
    where 0<retired}

/ q)wpt:wtp exec projtitle from project
/ q)rat:wrt wpt
/ q)select from rat where 0<retired
/ q)`funded xdesc rat
/ q)wps:wtp exec projsummary from project
/ q)ras:wrt wps
/ q)select from ras where 0<retired
/ q)`funded xdesc ras
/ q)wpn:wtp exec projneed from project / etc
/ q)ran:wrt wpn
/ q)p:(select projid,projtitle,projsummary,projneed from project) lj `projid xkey select projid,total_raised,projamt from pns
/ q)a:desc avg each({(x-y)%y}. p`total_raised`projamt)wpt
/ q)b:desc avg each({(x-y)%y}. p`total_raised`projamt)wps
/ q)c:desc avg each({(x-y)%y}. p`total_raised`projamt)wpn

////////////////////////////////////////////////////////////////////////
// value outcome impact

// select distinct amount by projid from value_outcome
// `projid xasc `n xdesc select n:sum quantity by projid, amount from rcptitem

// what % are chosen from value_outcome options given?
// exec sum[amount in'vo]%count i from rcptitem lj select distinct vo:`real$amount by projid from value_outcome
// Exclude projects that don't offer value_outcome options
// exec sum[amount in'vo]%count i from (select projid,amount from rcptitem where projid in exec distinct projid from value_outcome) lj select distinct vo:`real$amount by projid from value_outcome

// Can we say anything about donations whose amounts are not value_outcome amounts?
// `amount xasc{select from x where 10<=amount,not amount in'vo}(select projid,amount from rcptitem where projid in exec distinct projid from value_outcome) lj select distinct vo:`real$amount by projid from value_outcome
// select count i by bucket from update bucket:100 xbar`int$100*pct from update pct:amount%vo from update avg each vo from `amount xasc{select from x where 10<=amount,not amount in'vo}(select projid,amount from rcptitem where projid.status in`funded`retired,projid in exec distinct projid from value_outcome) lj select distinct vo:`real$amount by projid from value_outcome

// Does the min suggested donation have an impact?
// `pct_raised xdesc(select pct_raised:sum[amount*quantity]%first projid.projamt by projid from rcptitem where projid in(exec distinct projid from value_outcome),projid.status in`funded`retired)lj select mvo:min amount by projid from value_outcome
mvo_raised:{
  mvo:select mvo:min amount by projid from value_outcome;
  pr:select pct_raised:sum[amount*quantity]%first projid.projamt
       by projid
       from rcptitem
       where projid.status in`funded`retired,
             projid in exec distinct projid from value_outcome;
  p:()xkey select avg pct_raised by mvo from pr lj mvo;
  // causes wsfull ?!  update h:(`int$100%pct_raised)#\:"*" from p
  flip(!).((key;value)@\:flip p),'(`h;enlist(`int$100*p`pct_raised)#\:"*")}

// Are donors scared by large value_outcome amounts?
// try summing amounts of all bullets
svo_raised:{
  svo:select svo:sum amount by projid from value_outcome;
  pr:select pct_raised:sum[amount*quantity]%first projid.projamt
       by projid
       from rcptitem
       where projid.status in`funded`retired,
             projid in exec distinct projid from value_outcome;
  p:()xkey select avg pct_raised by svo from pr lj svo;
  // causes wsfull ?!  update h:(`int$100%pct_raised)#\:"*" from p
  flip(!).((key;value)@\:flip p),'(`h;enlist(`int$100*p`pct_raised)#\:"*")}

// Difference in sum of value_outcome amounts between winners and losers?
// pr:select win:signum -.7+sum[amount*quantity]%first projid.projamt by projid from rcptitem where projid.status in`funded`retired,projid in exec distinct projid from value_outcome
// select avg[amount],dev amount by win from pr lj select sum amount by projid from value_outcome
// select avg[amount],dev amount by win from pr lj select sum 3 sublist desc amount by projid from value_outcome

bigvo:{
  pr:select first projid.projthemeid,
            win:1=signum -.7+sum[amount*quantity]%first projid.projamt
       by projid
       from rcptitem
       where projid.status=`funded,
             projid in exec distinct projid from value_outcome;
  select winbig:sum[win&bigvo]%count i,
         winsma:sum[win&not bigvo]%count i,
         losbig:sum[(not win)&bigvo]%count i,
         lossma:sum[(not win)&not bigvo]%count i,
         n:count i
    by projthemeid
    from pr lj select bigvo:any 2500<=amount by projid from value_outcome}

// Do projects with high projamt values also have high value_outcome amounts?
// `sumbullets xdesc (select sumbullets:sum amount by projid from value_outcome where projid.status=`funded)lj`projid xkey select projid,projamt,total_raised from pns

// how many projects have a given # of value outcomes
// `n xdesc update h:(`int$log projid)#\:"*" from select count projid by n from select n:count i by projid from value_outcome

// select avgpct:avg pct, medpct:med pct,minpct:min pct, maxpct:max pct by hasvo from select pct:total_raised%projamt,hasvo:projid in (exec distinct projid from value_outcome) from pns

////////////////////////////////////////////////////////////////////////
// Time series
// patterns by
//    project duration: (`date$projid.deactivateDate)-`date$(first;creatdt)fby projid from rcptitem
//    project location
//    organization location
//    projthemeid?
// select donations:sum 0<raised,refunds:sum 0>raised,sum raised by projid,month from update month:(`month$creatdt)-`month$first creatdt by projid from `projid`creatdt xasc select projid,creatdt,raised:amount*quantity from rcptitem where projid.status in`funded
//
// dq:{select from x where 0<=durq}select durq:first div[;3](`month$projid.deactivateDate)-`month$first creatdt by projid from rcptitem;
// select sum amount*quantity by durq from (select from rcptitem where projid.status=`funded)lj dq
//
// a:`projid`creatdt xasc select projid,creatdt,raised:amount*quantity from rcptitem where projid.status in`funded;
// b:update durm:(`month$projid.deactivateDate)-`month$first creatdt,month:(`month$creatdt)-`month$first creatdt by projid from a;
// c:select first durm,first creatdt,donations:sum 0<raised,refunds:sum 0>raised,sum raised by projid,month from b where durm>=0;
//
// Grouping by year doesn't show anything
// update h:(0|`int$.05*raised)#\:"*" from select avg donations,avg refunds,avg raised by month from c where 12>=durm
// update h:(0|`int$.05*raised)#\:"*" from select avg donations,avg refunds,avg raised by month from c where durm within 13 24
// update h:(0|`int$.05*raised)#\:"*" from select avg donations,avg refunds,avg raised by month from c where durm>=25
//
// All together suggests a downward trend as time goes by overlaid with
// spikes (e.g., durm=8 and durm=30) // due to major disaster campaigns
// update h:(0|`int$.05*raised)#\:"*" from select avg raised by durm from c
//
// Doing proportions by campaign duration shows a clear, strong, downward trend:
// most money is raised in the first several weeks regardless of how long the campaign is.
// Long projects do often see a bump on their anniversaries.
// rack:ungroup select month:til first durm,durm,donations:0i,refunds:0i,raised:0e by projid from c;
// p:select from c where 0<=(`month$projid.deactivateDate)-`month$creatdt;
// q:update pct_raised:{min 1,x}each raised%sum raised by projid from rack lj keys[p]xkey cols[rack]#()xkey p;
// x:update h:(0|`int$200*pct_raised)#\:"*" from select avg pct_raised by durm,month from q
//
// By quarters
// y:update h:(0|`int$200*pct_raised)#\:"*" from select avg pct_raised by durq:durm div 3,quarter:month div 3 from q
//
// By projthemeid - note anomaly in health at 30 months; warrants investigation?
// update h:(`int$.0005*raised)#\:"*" from select sum donations,sum refunds,sum raised by projid.projthemeid,month from p




// How many users donated to each project
// `n xdesc select n:count distinct rcptid.uauserid by projid from rcptitem

// How many users donate to multiple campaigns?
// exec count distinct rcptid.uauserid from rcptitem
// => 509793
// exec sum usercount from (select usercount:count uauserid by projcount:n from select n:count distinct projid by rcptid.uauserid from rcptitem)where 1<projcount
// => 71048
// update h:(`int$log usercount)#\:"*" from select usercount:count uauserid by projcount:n from select n:count distinct projid by rcptid.uauserid from rcptitem
// update h:(`int$log usercount)#\:"*" from select usercount:count uauserid by projcount:5 xbar n from select n:count distinct projid by rcptid.uauserid from rcptitem

// Time series CDF of first month
// p:select sum amount*quantity by projid,payday:(`date$creatdt)-`date$projid.createdt from rcptitem
// update h:(`int$.00005*amount)#\:"*" from select sum amount by payday from p where payday within 0 30

// Deciles of projects: what % of goal to the top 10% achieve etc
// update h:(`int$20*pct)#\:"*" from ([]decile:til 10;pct:avg each 10 0N#exec asc amount from select from (select sum[amount*quantity]%first projid.projamt by projid from rcptitem)where not null amount,0<=amount)



////////////////////////////////////////////////////////////////////////
// funding rate: total raised divided by duration (deactivateDate-approvedt)
//
frate:{
  `funding_rate xdesc
    update funding_rate:raised%days,
           funding     :raised%projamt
      from {delete from x where 0>=days}
        (select projid,
                days:(`date$deactivateDate)-`date$approveddt,
                projamt
           from project)
          lj
        select raised:sum amount*quantity by projid from rcptitem}

fmrate:{
  `funding_rate xdesc
    update funding_rate:raised%months,
           funding     :raised%projamt
      from {delete from x where 0>=months}
        (select projid,
                months:(`month$deactivateDate)-`month$approveddt,
                projamt
           from project)
          lj
        select raised:sum amount*quantity by projid from rcptitem}

// TODO: write bins function
// natural jinks clustering
